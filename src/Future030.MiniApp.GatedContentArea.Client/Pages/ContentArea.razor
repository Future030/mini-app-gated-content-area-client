@page "/content/{Area}"
@using Future030.MiniApp.GatedContentArea.Client.Services
@using JetBrains.Annotations
@inject ILogger<ContentArea> Logger;
@inject IJSRuntime JSRuntime;
@inject IContentService ContentService;

<h3>Exclusive Content Area</h3>

@if (!_isAuthenticated)
{
    <p>You are not logged in.</p>
}
else if (!_hasAccess)
{
    <p>You don't have the required token to access this content.</p>
}
else
{
    <p>Welcome, Universal Profile: @_connectionState?.VisitorAddress</p>
    <p>Chain ID: @_connectionState?.ChainId</p>
    <div class="image-gallery">
        @foreach (var image in _images)
        {
            <img src="@image" alt="Exclusive Content" style="width:100%; margin-bottom:10px;" />
        }
    </div>
}

@code {
    [Parameter] public string Area { get; set; } = string.Empty;

    private bool _isAuthenticated;
    private bool _hasAccess;
    private ConnectionState? _connectionState;
    private List<string> _images = new();

    protected override async Task OnInitializedAsync()
    {
        await JSRuntime.InvokeVoidAsync("upProviderInterop.initializeState", DotNetObjectReference.Create(this));
        await FetchAndVerifyConnectionState();
    }

    private async Task FetchAndVerifyConnectionState()
    {
        Logger.LogTrace("Fetching and verifying connection state for Area: {Area}", Area);
        try
        {
            Logger.LogInformation("üîπ Checking connection state...");

            // Fetch the connection state
            _connectionState = await JSRuntime.InvokeAsync<ConnectionState>("upProviderInterop.getConnectionState");
            Logger.LogDebug("Connection state fetched: {@ConnectionState}", _connectionState);

            // Validate retrieved data
            if (_connectionState == null ||
                string.IsNullOrEmpty(_connectionState.VisitorAddress) ||
                string.IsNullOrEmpty(_connectionState.OwnerAddress) ||
                !_connectionState.ChainId.HasValue)
            {
                _isAuthenticated = false;
                _hasAccess = false;
                Logger.LogWarning("‚ùå Missing connection state data. Details: {@ConnectionState}", _connectionState);
                return;
            }

            Logger.LogInformation("‚úÖ Connection state is valid. Details: {@ConnectionState}", _connectionState);

            _isAuthenticated = true;

            // TODO: Security
            // // Generate a nonce
            // string nonce = Guid.NewGuid().ToString();
            // Logger.LogDebug("üîπ Generated Nonce: {Nonce}", nonce);
            //
            // // Sign the nonce
            // Logger.LogTrace("Requesting signature for the nonce...");
            // var signature = await JSRuntime.InvokeAsync<string>("upProviderInterop.signMessage", nonce);
            // if (string.IsNullOrEmpty(signature))
            // {
            //     Logger.LogError("‚ùå Failed to sign the nonce: {Nonce}", nonce);
            //     return;
            // }
            // Logger.LogDebug("üîπ Signature generated: {Signature}", signature);

            // Prepare request data and send to backend
            var requestPayload = new GatedContentRequest(
                _connectionState.VisitorAddress,
                _connectionState.OwnerAddress,
                _connectionState.ChainId!.Value,
                Area, Guid.NewGuid().ToString(), string.Empty);
            Logger.LogInformation("Sending gated content request with payload: {Payload}", requestPayload);

            var response = await ContentService.GetGatedContentAsync(requestPayload);

            // Handle response
            if (response?.Count > 0)
            {
                Logger.LogInformation("‚úÖ Access Granted. Loaded {Count} images", response.Count);
                _images = response;
                _hasAccess = true;
            }
            else
            {
                Logger.LogWarning("‚ùå Access Denied. No images returned");
                _hasAccess = false;
            }
        }
        catch (Exception ex)
        {
            _isAuthenticated = false;
            _hasAccess = false;
            Logger.LogError(ex, "‚ùå Error occurred in FetchAndVerifyConnectionState. Area: {Area}", Area);
        }
        finally
        {
            Logger.LogTrace("FetchAndVerifyConnectionState method completed for Area: {Area}", Area);
            StateHasChanged();
        }
    }

    // JavaScript Interop for Reactive State Updates
    [JSInvokable]
    public async Task StateUpdated()
    {
        Console.WriteLine("üîÑ Reacting to connection state updates...");
        await FetchAndVerifyConnectionState();
    }
    
    // Define the ConnectionState model
    [UsedImplicitly(ImplicitUseTargetFlags.Members)]
    public class ConnectionState
    {
        public string? VisitorAddress { get; set; }
        public string? OwnerAddress { get; set; }
        public int? ChainId { get; set; }
    }
}